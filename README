
Παραδειγματα κλησης του προγραμματος:
|----------------------------1----------------------------|
$ make
$ ./output
Input the name of your file: data.txt
Input number of child processes: 100
Input number of queries: 10

|----------------------------2----------------------------|
$ make
$ ./output < input.txt




1)Το makefile φτιαχνει ενα executable με ονομα "output"
2)H main διεργασια ειναι void, δηλαδη δεν παιρνει arguments οταν καλειται
3)Τα δεδομενα τα παιρνει ως input με getline για το ονομα του αρχειου και scanf για τον αριθμο παιδιων και ερωτηματων, μεσω των συναρτησεων read_functions
4)Το data.txt εχει lines που αναφερουν τον αριθμο τους, για το testing του προγραμματος
5)Για το shared memory εφτιαξα αλλες συναρτησεις, βασισμενες στις shm, για να ειναι πιο ευκολες στην χρηση
    a)Οι νεες συναρτησεις shared memory παιρνουν ως μονη παραμετρο το "key" (το οποιο και οριζω στο main προγραμμα) 
    b)Δημιουργουν block μεγεθους 4096, το οποιο οριζεται στο shared_memory.h
    c)Η συναρτηση create_shared_memory_block χρησιμοποιειται μια φορα στην αρχη του προγραμματος 
    d)Οποιος θελει να χρησιμοποιησει την μνημη αυτη κανει attach για να την "πειραξει" και detach οταν τελειωσει
    e)Στο τελος του προγραμματος καλειται και η destroy
6)Χρησιμοποιησα mmap για την μνημη που φυλασσει (int) τον αριθμο της γραμμης που ζηταει το παιδι
7)Για την επικοινωνια μεταξυ παιδιων-γονεα εκανα χρηση τριων (3) σεμαφορων
    a)Ο πρωτος (sem_child_lock) ειναι για το critical section των παιδιων. Αρχικοποιειται με value 1
    b)τον διαχειριζονται μονα τους τα παιδια (με wait στην αρχη του critical section και post στο τελος)
    c)Οι αλλοι δυο (sem_request/sem_response) ειναι για την αναδραση μεταξυ των διεργασιων (ο πατερας κανει wait το request και post το response και το παιδι το αναποδο)
8)Το critical section βρησκεται μεσα στο loop των παιδιων, που σημαινει οτι το request το κανει οποιο παιδι προλαβει καθε φορα (δεν περιμενουν τα αλλα παιδια να τελειωσει με ολα τα requests του)
9)Για τον χρονο, εκανα χρηση της clock_gettime αντι για clock που δινει CPU time και οχι realtime.
10)Για τον πατερα εβαλα for-loop για τον προκαθορισμενο αριθμο ερωτηματων ανα παιδι που ξερει οτι θα λαβει (K*N) 



Γενικα ο τροπος που δουλευει το προγραμμα, ειναι οτι παιρνει η αρχικη διεργασια ορισματα, για το file που θα διαβασει, για τις διεργασιες που θα δημιουργησει 
και για τα ερωτηματα που θα του κανουν οι υποκειμενες διεργασιες (μεσω των read συναρτησεων). Μετα, η αρχικη διεργασια κανει fork σε ενα loop, 
στο οποιο loop επιτρεπεται μονο η ιδια να κανει fork (για να μην δημιουγηθουν παιδια παιδιων).

Καθε παιδι μπαινει σε ενα loop (για να εκτελεσει τον επιθυμητο αριθμο ερωτηματων), κλειδωνει την περιοχη (μεσω του σημαφορου sem_child_lock), 
παιρνει εναν τυχαιο αριθμο, απο το 1 μεχρι τον μεγιστο αριθμο των γραμμων του file που ο πατερας διαβασε, ζηταει την γραμμη (η οποια εχει γραφτει στο shared memory)
μεσω post (sem_request), αρχιζει να μετραει τον χρονο, και κανει wait (sem_response). 
Οταν παρει την απαντηση απο τον πατερα συνεχιζει, υπολογιζει τον χρονο που περιμενε, διαβαζει την γραμμη απο το shared memory block, την τυπωνει
και κανει exit το critical section (μεσω post του sem_child_lock). Οταν ενα παιδι, τελειωσει με ολα τα ερωτηματα του τοτε κανει 
post τον μεσο ορο του χρονου που εκανε για να λαβει απαντηση απο τον πατερα.

Ο πατερας, οταν τελειωσει με το να δημιουργει τα παιδια, μπαινει σε loop για τον συνολικο αριθμο ερωτηματων που θα δεχθει και περιμενει ερωτημα απο καποιο παιδι
(κανοντας wait το sem_request)
Στην συνεχεια διαβαζει την requested γραμμη απο το file (μεσω της read_line_from_file), κανει copy το string στο shared memory
και σηματοδοτει στο παιδι οτι η απαντηση ειναι ετοιμη (μεσω post στο sem_response).
Οταν τελειωσει με ολα τα ερωτηματα, κανει free ολη την δεσμευμενη μνημη και τους σεμαφορους.














